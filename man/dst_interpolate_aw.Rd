% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dst_interpolate_aw.R
\name{dst_interpolate_aw}
\alias{dst_interpolate_aw}
\title{Areal-weighted interpolation of polygon data (DuckDB-backed)}
\usage{
dst_interpolate_aw(
  target_sf, tid, source_sf, sid, weight = "sum", output = "sf",
  extensive, intensive, source_crs = NULL, target_crs = NULL, join_crs = NULL,
  duckdb_threads = NULL, na.rm = FALSE, keep_NA = TRUE
)
}
\arguments{
\item{target_sf}{A \code{sf} object with polygons to which values are interpolated
(the target geometry).}

\item{tid}{A column in \code{target_sf} that uniquely identifies target features.}

\item{source_sf}{A \code{sf} object with polygons providing the values to interpolate
(the source geometry).}

\item{sid}{A column in \code{source_sf} that uniquely identifies source features.}

\item{weight}{For spatially extensive variables, either \code{"sum"} (default) or
\code{"total"}. For spatially intensive variables, use \code{"sum"}.}

\item{output}{One of \code{"sf"} (default) or \code{"tibble"} for the return type.}

\item{extensive}{Character vector of column names in \code{source_sf} treated as
spatially extensive (e.g., counts). Optional if \code{intensive} is supplied.}

\item{intensive}{Character vector of column names in \code{source_sf} treated as
spatially intensive (e.g., rates/densities). Optional if \code{extensive} is supplied.}

\item{source_crs, target_crs}{Optional CRS specifications for the source/target inputs.
If omitted, they are inferred from \code{sf::st_crs(source_sf)} and
\code{sf::st_crs(target_sf)} respectively. Accepts EPSG code (numeric) or
WKT/PROJJSON (character).}

\item{join_crs}{Optional CRS used for the spatial join and area calculations.
If omitted, defaults to \code{target_crs}. \strong{Use a projected CRS} for area-based work.}

\item{duckdb_threads}{Optional integer: number of DuckDB threads. If \code{NULL}, the
DuckDB default is used.}

\item{na.rm}{Logical; if \code{TRUE}, drops rows from \code{source_sf} with any \code{NA}
in the variables being interpolated. Defaults to \code{FALSE}.}

\item{keep_NA}{Logical; if \code{FALSE}, drops targets where all requested interpolated
variables are \code{NA}. Defaults to \code{TRUE}.}
}
\value{
An \code{sf} object (default) with interpolated variables merged to
\code{target_sf}, or a \code{tibble} when \code{output = "tibble"}.
}
\description{
A fast, DuckDB Spatial-backed reimplementation of areal-weighted interpolation found in \code{\link[areal:aw_interpolate]{areal::aw_interpolate()}} and \code{\link[sf:st_interpolate_aw]{sf::st_interpolate_aw()}}. It performs all calculations using a temporary in-memory DuckDB database.
}
\details{
Areal-weighted interpolation estimates values for overlapping but non-congruent polygons and assumes the attribute is evenly distributed across each source polygon. Results are most reliable when a projected CRS is used for area calculations.

\strong{CRS handling.} DuckDB does not persist CRS metadata. CRS values used here are \strong{inferred from the provided \code{sf} objects} via \code{sf::st_crs()} and then passed to DuckDB Spatial as EPSG/WKT/PROJJSON literals for transformations. If \code{source_crs}/\code{target_crs} are not supplied, they default to the CRS of the corresponding \code{sf} objects. \code{join_crs} defaults to \code{target_crs}. For area-based workflows, supply a \strong{projected} \code{join_crs}.

\strong{Weights.} For spatially extensive variables, \code{weight = "sum"} uses the \emph{intersected} area per source feature as the denominator; \code{weight = "total"} uses the full source polygon area. For spatially intensive variables, denominators are computed per target using the sum of intersected areas and \code{weight = "sum"}.
}
\examples{
\dontrun{
# Sketch (using your own sf objects):
res <- dst_interpolate_aw(
  target_sf = target,
  tid       = target_id,
  source_sf = source,
  sid       = source_id,
  weight    = "sum",
  extensive = c("pop_total", "jobs"),
  intensive = "density",
  join_crs  = 3857
)
}

}
\references{
Prener, C. and Revord, C. (2019). \emph{areal: An R package for areal weighted interpolation}.
\emph{Journal of Open Source Software}, 4(37), 1221.
Available at: \url{https://doi.org/10.21105/joss.01221}
}
\seealso{
\code{\link[areal:aw_interpolate]{areal::aw_interpolate()}} â€” reference implementation.
}
