% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/st_interpolate_aw.R
\name{st_interpolate_aw_ducksf}
\alias{st_interpolate_aw_ducksf}
\alias{st_interpolate_aw}
\title{Areal-weighted interpolation via DuckDB (no masking)}
\usage{
st_interpolate_aw_ducksf(x, to, extensive, ..., keep_NA = FALSE, na.rm = FALSE)

st_interpolate_aw(x, to, extensive, ..., keep_NA = FALSE, na.rm = FALSE)
}
\arguments{
\item{x}{An \code{sf} object with source polygons and attributes to interpolate.}

\item{to}{An \code{sf} or \code{sfc} with target polygons (coerced via \code{sf::st_as_sf()} if needed).}

\item{extensive}{Either a single logical (sf semantics) or a character vector of
column names to treat as spatially extensive (package extension).}

\item{...}{Ignored; present for drop-in compatibility with \code{sf}.}

\item{keep_NA}{Logical; if \code{FALSE}, drop targets with no contributions in the
requested variables (matches sf).}

\item{na.rm}{Logical; if \code{TRUE}, drop rows of \code{x} that contain any \code{NA} before
interpolation (matches sf).}
}
\value{
An \code{sf} object with interpolated variables merged to \code{to}.
}
\description{
\code{st_interpolate_aw_ducksf()} is a user-facing, \strong{non-masking} wrapper that
reproduces the semantics of \code{sf::st_interpolate_aw()} while delegating work
to \code{\link[=dst_interpolate_aw]{dst_interpolate_aw()}}. It never masks \code{sf}; call it explicitly.

There is also an \strong{internal} shim, \code{st_interpolate_aw()} (unexported),
with the same signature. It exists so that a future, optional
preference mechanism (e.g. via the \strong{conflicted} package) could prefer
ducksfâ€™s implementation without changing the search path. In this package
version, no masking is performed.
}
\details{
Areal-weighted interpolation via DuckDB (no masking)
\itemize{
\item \strong{CRS} is inferred from inputs and passed to DuckDB as EPSG/WKT/JSON; for
area work, use a projected CRS via \code{join_crs} in \code{\link[=dst_interpolate_aw]{dst_interpolate_aw()}}.
\item \strong{Weights mapping (sf semantics):} if any variables are treated as \emph{extensive},
the shim uses \code{weight = "total"}; otherwise \code{weight = "sum"}.
}
}
\examples{
\dontrun{
# Explicit, no masking:
res <- ducksf::st_interpolate_aw_ducksf(x = src_sf, to = tgt_sf, extensive = TRUE)

# Original sf still available:
res_sf <- sf::st_interpolate_aw(x = src_sf, to = tgt_sf, extensive = TRUE)
}

}
\seealso{
\itemize{
\item \code{sf::st_interpolate_aw()} for the original,
\item \code{\link[=dst_interpolate_aw]{dst_interpolate_aw()}} for the fast-path API.
}
}
\keyword{internal}
