[{"path":"http://www.ekotov.pro/ducksf/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 ducksf authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://www.ekotov.pro/ducksf/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Egor Kotov. Author, maintainer, copyright holder.","code":""},{"path":"http://www.ekotov.pro/ducksf/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kotov E (2024). ducksf. Spatial Ops Faster sf geos. https://github.com/e-kotov/ducksf.","code":"@Manual{ducksf,   title = {ducksf. Spatial Ops Faster Than sf and geos},   author = {Egor Kotov},   year = {2024},   url = {https://github.com/e-kotov/ducksf}, }"},{"path":"http://www.ekotov.pro/ducksf/index.html","id":"ducksf-spatial-ops-faster-than-sf-and-geos-","dir":"","previous_headings":"","what":"ducksf","title":"ducksf","text":"package provides alternatives sf functions, implemented using duckdb geoarrow. far implemented function areal interpolation working similar one fiund ‘areal’ package, much faster. idea project go, use risk. ducksf provides fast, DuckDB Spatial–backed spatial data operations R, current focus areal-weighted interpolation drop-alternative tosf::st_interpolate_aw() areal::aw_interpolate(). ’s can expect speed gains memory savings (measured projected planar data):   can see figures, ducksf much faster areal::aw_interpolate() (sf::st_interpolate_aw(), works way, functionally limited), especially large datasets. also uses less memory, crucial working large spatial datasets. Even though cost translating sf objects DuckDB tables back, overall performance significantly improved. misterious geosareal package just proof--concept package also implements areal interpolation, using geos instead duckdb. meant used production maintained, code available : https://github.com/e-kotov/r-geos-areal-weighted-interpolation-prototype.","code":""},{"path":"http://www.ekotov.pro/ducksf/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"ducksf","text":"can install development version ducksf GitHub :","code":"# install.packages(\"pak\") pak::pak(\"e-kotov/ducksf\")"},{"path":"http://www.ekotov.pro/ducksf/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"ducksf","text":"basic example shows solve common problem (following sf package’s example - result little different, project data NAD83 / Conus Albers (EPSG:5070)):","code":"## Quick example (using the default `sf` dataset) library(sf) library(ducksf)  # data & grid (from sf help) nc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE) # transform to NAD83 / Conus Albers (EPSG:5070) nc <- nc |> st_transform(5070) g <- st_make_grid(nc, n = c(10, 5)) # 'to' can be sfc for sf, but ducksf core needs an sf with an ID  # Prepare IDs for ducksf core nc$src_id <- seq_len(nrow(nc)) g_sf <- st_as_sf(g) g_sf$tid <- seq_len(nrow(g_sf))  ## 1) ducksf core (dst_interpolate_aw) --------------------------------------  # (a) Treat BIR74 as spatially intensive (not mass-preserving) a1_core <- dst_interpolate_aw(   target_sf = g_sf,   tid = \"tid\",   source_sf = nc,   sid = \"src_id\",   weight = \"sum\", # intensive semantics   intensive = \"BIR74\",   output = \"sf\" ) sum(st_drop_geometry(a1_core)$BIR74, na.rm = TRUE) / sum(nc$BIR74, na.rm = TRUE)  # (b) Treat BIR74 as spatially extensive (mass-preserving) a2_core <- dst_interpolate_aw(   target_sf = g_sf,   tid = \"tid\",   source_sf = nc,   sid = \"src_id\",   weight = \"total\", # extensive semantics (pycnophylactic)   extensive = \"BIR74\",   output = \"sf\" ) sum(st_drop_geometry(a2_core)$BIR74, na.rm = TRUE) / sum(nc$BIR74, na.rm = TRUE)  # Quick plot (intensive vs extensive) a_show <- a1_core[, \"BIR74\"] names(a_show)[1] <- \"intensive\" a_show$extensive <- st_drop_geometry(a2_core)$BIR74 plot(a_show[c(\"intensive\", \"extensive\")], key.pos = 4)"},{"path":"http://www.ekotov.pro/ducksf/index.html","id":"mask-sf-functions","dir":"","previous_headings":"","what":"Mask {sf} functions","title":"ducksf","text":"ducksf also provides way mask sf functions dispatch ducksf instead sf. useful want use sf functions ducksf semantics without changing code much. default course disabled, can use sf functions usual even ducksf loaded. resulting numbers insignificantly different sf results due rounding errors, close.","code":"## 2) Masked drop-in (sf semantics) -----------------------------------------  # Enable/disable masking so st_interpolate_aw() dispatches to ducksf sf_use_ducksf(TRUE) # or: sf_use_ducksf(TRUE, allow = \"st_interpolate_aw\") sf_use_ducksf(FALSE) # or: sf_use_ducksf(TRUE, allow = \"st_interpolate_aw\")  a1 <- st_interpolate_aw(nc[\"BIR74\"], g, extensive = FALSE) sum(a1$BIR74) / sum(nc$BIR74) # not close to 1 (intensive)  a2 <- st_interpolate_aw(nc[\"BIR74\"], g, extensive = TRUE) sum(a2$BIR74) / sum(nc$BIR74) # ≈ 1 (mass-preserving)  # Compare maps exactly like sf's example a1$intensive <- a1$BIR74 a1$extensive <- a2$BIR74 plot(a1[c(\"intensive\", \"extensive\")], key.pos = 4)  # Disable masking when done sf_use_ducksf(FALSE)"},{"path":"http://www.ekotov.pro/ducksf/index.html","id":"to-test-speed-on-relatively-large-data","dir":"","previous_headings":"","what":"To test speed on relatively large data","title":"ducksf","text":"data code used tests presented top README, bench::mark() function","code":"install.packages(setdiff(   c(     \"duckdb\",     \"sf\",     \"areal\",     \"geoarrow\",     \"terra\",     \"geodata\",     \"giscoR\",     \"tidyverse\",     \"tictoc\"   ),   rownames(installed.packages()) ))   library(duckdb) library(sf) library(areal) library(geoarrow) library(terra) library(geodata) library(giscoR) library(areal) library(tidyverse) library(tictoc) library(ducksf) # remotes::install_github(\"e-kotov/ducksf\") # also optional if you want to try it yourself, geosareal also does quite well compared to sf-based interpolation # library(geosareal) # remotes::install_github(\"e-kotov/r-geos-areal-weighted-interpolation-prototype\")  # get data dir.create(\"private/data\", recursive = TRUE) pop <- geodata::population(year = 2020, res = 2.5, path = \"private/data\") # GPWv4 density nuts2 <- giscoR::gisco_get_nuts(year = \"2021\", nuts_level = 2, epsg = \"4326\") fr2 <- subset(nuts2, CNTR_CODE == \"FR\") fr2_mainland <- subset(fr2, !grepl(\"^FRY|^FRM\", NUTS_ID))  # crop pop raster to mainland France pop_fr <- terra::crop(   pop,   st_bbox(fr2_mainland),   snap = \"out\" ) # mask pop_fr <- terra::mask(pop_fr, fr2_mainland)  # project the raster to EPSG:3035 (ETRS89 / LAEA Europe) pop_fr <- terra::project(   pop_fr,   \"EPSG:3035\",   method = \"bilinear\" )  # vectorize the raster # yes, let's imagine there is no terra::extract() or exactextractr::exact_extract() # and you are bound to the vector world pop_fr_vec <- as.polygons(pop_fr, aggregate = FALSE) |>   st_as_sf() |>   mutate(cell_id = as.character(row_number()))  # generate a hexagonal grid over mainland France bbox_fr <- st_bbox(st_transform(fr2_mainland, 3035))  cellsize_hex <- 2500 # 2.5 km hexagons # also try pushing it down to 1km hexes to push the limits of your computer  hex <- st_make_grid(bbox_fr, cellsize = cellsize_hex, square = FALSE) |>   st_as_sf() |>   st_set_geometry(\"geometry\") |>   mutate(hex_id = as.character(row_number())) nrow(hex) # 171k, would be just over 1 million for 1km hexes format(object.size(hex), \"Mb\") # ~200 mb, would be 1,200 mb for 1km hexes   aw_test <- areal::ar_validate(   source = pop_fr_vec,   target = hex,   varList = \"population_density\",   method = \"aw\",   verbose = TRUE ) aw_test   Sys.time() tictoc::tic() hex_areal <- areal::aw_interpolate(   .data = hex,   tid = hex_id,   source = pop_fr_vec,   sid = cell_id,   weight = \"total\",   output = \"tibble\",   extensive = \"population_density\" ) tictoc::toc() Sys.time()   Sys.time() tictoc::tic() hex_ducksf <- ducksf::dst_interpolate_aw(   target_sf = hex,   tid = \"hex_id\",   source_sf = pop_fr_vec,   sid = \"cell_id\",   weight = \"total\",   output = \"tibble\",   extensive = \"population_density\" ) tictoc::toc() Sys.time()   Sys.time() tictoc::tic() hex_geos <- geosareal::geos_interpolate_aw(   .data = hex,   tid = hex_id,   source = pop_fr_vec,   sid = cell_id,   weight = \"total\",   output = \"tibble\",   extensive = \"population_density\" ) tictoc::toc() Sys.time()"},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":null,"dir":"Reference","previous_headings":"","what":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"fast, DuckDB Spatial-backed reimplementation areal-weighted interpolation found areal::aw_interpolate() sf::st_interpolate_aw(). performs calculations using temporary -memory DuckDB database.","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"","code":"dst_interpolate_aw(   target_sf, tid, source_sf, sid, weight = \"sum\", output = \"sf\",   extensive, intensive, source_crs = NULL, target_crs = NULL, join_crs = NULL,   duckdb_threads = NULL, na.rm = FALSE, keep_NA = TRUE )"},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"target_sf sf object polygons values interpolated (target geometry). tid column target_sf uniquely identifies target features. source_sf sf object polygons providing values interpolate (source geometry). sid column source_sf uniquely identifies source features. weight spatially extensive variables, either \"sum\" (default) \"total\". spatially intensive variables, use \"sum\". output One \"sf\" (default) \"tibble\" return type. extensive Character vector column names source_sf treated spatially extensive (e.g., counts). Optional intensive supplied. intensive Character vector column names source_sf treated spatially intensive (e.g., rates/densities). Optional extensive supplied. source_crs, target_crs Optional CRS specifications source/target inputs. omitted, inferred sf::st_crs(source_sf) sf::st_crs(target_sf) respectively. Accepts EPSG code (numeric) WKT/PROJJSON (character). join_crs Optional CRS used spatial join area calculations. omitted, defaults target_crs. Use projected CRS area-based work. duckdb_threads Optional integer: number DuckDB threads. NULL, DuckDB default used. na.rm Logical; TRUE, drops rows source_sf NA variables interpolated. Defaults FALSE. keep_NA Logical; FALSE, drops targets requested interpolated variables NA. Defaults TRUE.","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"sf object (default) interpolated variables merged target_sf, tibble output = \"tibble\".","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"Areal-weighted interpolation estimates values overlapping non-congruent polygons assumes attribute evenly distributed across source polygon. Results reliable projected CRS used area calculations. CRS handling. DuckDB persist CRS metadata. CRS values used inferred provided sf objects via sf::st_crs() passed DuckDB Spatial EPSG/WKT/PROJJSON literals transformations. source_crs/target_crs supplied, default CRS corresponding sf objects. join_crs defaults target_crs. area-based workflows, supply projected join_crs. Weights. spatially extensive variables, weight = \"sum\" uses intersected area per source feature denominator; weight = \"total\" uses full source polygon area. spatially intensive variables, denominators computed per target using sum intersected areas weight = \"sum\".","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"Prener, C. Revord, C. (2019). areal: R package areal weighted interpolation. Journal Open Source Software, 4(37), 1221. Available : https://doi.org/10.21105/joss.01221","code":""},{"path":[]},{"path":"http://www.ekotov.pro/ducksf/reference/dst_interpolate_aw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Areal-weighted interpolation of polygon data (DuckDB-backed) — dst_interpolate_aw","text":"","code":"if (FALSE) { # \\dontrun{ # Sketch (using your own sf objects): res <- dst_interpolate_aw(   target_sf = target,   tid       = target_id,   source_sf = source,   sid       = source_id,   weight    = \"sum\",   extensive = c(\"pop_total\", \"jobs\"),   intensive = \"density\",   join_crs  = 3857 ) } # }"},{"path":"http://www.ekotov.pro/ducksf/reference/sf_use_ducksf.html","id":null,"dir":"Reference","previous_headings":"","what":"Enable or disable preferring ducksf replacements over sf (no attach) — sf_use_ducksf","title":"Enable or disable preferring ducksf replacements over sf (no attach) — sf_use_ducksf","text":"Since ducksf export functions names sf, nothing prefer/mask runtime. helper kept backward compatibility just inform user.","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/sf_use_ducksf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enable or disable preferring ducksf replacements over sf (no attach) — sf_use_ducksf","text":"","code":"sf_use_ducksf(use = NULL, allow = NULL, deny = NULL, silent = FALSE)"},{"path":"http://www.ekotov.pro/ducksf/reference/sf_use_ducksf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enable or disable preferring ducksf replacements over sf (no attach) — sf_use_ducksf","text":"use Ignored (kept compatibility). allow Ignored. deny Ignored. silent Logical; TRUE, suppress messages.","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/sf_use_ducksf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enable or disable preferring ducksf replacements over sf (no attach) — sf_use_ducksf","text":"Invisibly returns character(0).","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":null,"dir":"Reference","previous_headings":"","what":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"st_interpolate_aw_ducksf() user-facing, non-masking wrapper reproduces semantics sf::st_interpolate_aw() delegating work dst_interpolate_aw(). never masks sf; call explicitly. also internal shim, st_interpolate_aw() (unexported), signature. exists future, optional preference mechanism (e.g. via conflicted package) prefer ducksf’s implementation without changing search path. package version, masking performed.","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"","code":"st_interpolate_aw_ducksf(x, to, extensive, ..., keep_NA = FALSE, na.rm = FALSE)  st_interpolate_aw(x, to, extensive, ..., keep_NA = FALSE, na.rm = FALSE)"},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"x sf object source polygons attributes interpolate. sf sfc target polygons (coerced via sf::st_as_sf() needed). extensive Either single logical (sf semantics) character vector column names treat spatially extensive (package extension). ... Ignored; present drop-compatibility sf. keep_NA Logical; FALSE, drop targets contributions requested variables (matches sf). na.rm Logical; TRUE, drop rows x contain NA interpolation (matches sf).","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"sf object interpolated variables merged .","code":""},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"Areal-weighted interpolation via DuckDB (masking) CRS inferred inputs passed DuckDB EPSG/WKT/JSON; area work, use projected CRS via join_crs dst_interpolate_aw(). Weights mapping (sf semantics): variables treated extensive, shim uses weight = \"total\"; otherwise weight = \"sum\".","code":""},{"path":[]},{"path":"http://www.ekotov.pro/ducksf/reference/st_interpolate_aw_ducksf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Areal-weighted interpolation via DuckDB (no masking) — st_interpolate_aw_ducksf","text":"","code":"if (FALSE) { # \\dontrun{ # Explicit, no masking: res <- ducksf::st_interpolate_aw_ducksf(x = src_sf, to = tgt_sf, extensive = TRUE)  # Original sf still available: res_sf <- sf::st_interpolate_aw(x = src_sf, to = tgt_sf, extensive = TRUE) } # }"}]
